#!/bin/bash

# btrfs-auto-snapshot for Linux
# Automatically create, rotate, and destroy periodic BTRFS snapshots.
# Copyright 2014 Doug Hunley <doug.hunley@gmail.com>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA

# set defaults
debug=''
dry_run=''
keep=''
label=''
prefix='btrfs-auto-snap'
use_syslog=''
verbose=''
quiet=''
writeable='-r'

ARGSP_ERR_STDIN_EMPTY=1

usage()
{
    echo "Usage: $0 [options] [-l label] <'//' | name [name...]>
    -d, --debug         Print debugging messages
    -g, --syslog        Write to syslog
    -h, --help          Print this usage message
    -k, --keep=NUM      Keep NUM recent snapshots and destroy older snapshots
    -l, --label=LAB     LAB is usually 'hourly', 'daily', or 'monthly'
    -n, --dry-run       Print actions w/o actually doing
    -p, --prefix=PRE    PRE is 'btrfs-auto-snap' by default
    -q, --quiet         Suppress warning and notices on STDOUT
    -v, --verbose       Print info messages
    -w, --writeable     Create writeable snapshots instead of read-only
    name                Filesystem name(s), or '//' for all filesystems
"
}

log()
{
    LEVEL=$1
    shift 1

    case $LEVEL in
        (eme*)
            test -n "$use_syslog" && logger -t "$prefix" -p daemon.emerge -- $*
            echo Emergency: $* 1>&2
            ;;
        (ale*)
            test -n "$use_syslog" && logger -t "$prefix" -p daemon.alert -- $*
            echo Alert: $* 1>&2
            ;;
        (cri*)
            test -n "$use_syslog" && logger -t "$prefix" -p daemon.crit -- $*
            echo Critical: $* 1>&2
            ;;
        (err*)
            test -n "$use_syslog" && logger -t "$prefix" -p daemon.err -- $*
            echo Error: $* 1>&2
            ;;
        (war*)
            test -n "$use_syslog" && logger -t "$prefix" -p daemon.warn -- $*
            echo Warning: $* 1>&2
            ;;
        (not*)
            test -n "$use_syslog" && logger -t "$prefix" -p daemon.notice -- $*
            test -n "$verbose" && echo Notice: $* 1>&2
            ;;
        (inf*)
            test -n "$verbose" && echo $*
            ;;
        (deb*)
            test -n "$debug" && echo Debug: $*
            ;;
        (*)
            test -n "$use_syslog" && logger -t "$prefix" -- $*
            echo $* 1>&2
            ;;
    esac
}

##
# {@code STDIN} can only be consumed once, so read and return it here for later processing.
#
# The current approach is to have one argument per line, so we are iterating all of those already,
# remove empty lines, comments etc. and are able to check if anything was read at all in the end. If
# not, this is most likely an error, as it doesn't make much sense to explicitly call us, so the
# script is aborted.
#
# @return {@code [0]="..." [1]="..." [...]}
# @see <a href="https://stackoverflow.com/a/16843375/2055163">How to return an array in bash without using globals?</a>
#
argsp_stdin_to_array()
{
  local -r stdin="$(cat '/dev/stdin')"
  local -a ret_val=()

  while IFS= read -r line; do
    local is_blank="$(  echo "${line}" | grep --count -e '^[[:space:]]*$')"
    local is_comment="$(echo "${line}" | grep --count -e '^#')"
    local is_empty="$(  echo "${line}" | grep --count -e '^$')"

    if [ "${is_blank}" = '1' ] || [ "${is_comment}" = '1' ] || [ "${is_empty}" = '1' ]
    then
      continue
    fi

    ret_val+=(${line})
  done <<< "${stdin}"

  if [ ${#ret_val[@]} -eq 0 ]
  then
    echo 'No arguments given using STDIN.' >&2
    exit ${ARGSP_ERR_STDIN_EMPTY}
  fi

  declare -p ret_val | sed -e 's/^declare -a [^=]*=//'
}

##
# Calculate all BTRFS subvolumes based on all mounted BTRFS file systems.
#
# "zfs-auto-snapshot" is not only able to snapshot all pools, but as well all individual datasets
# when using "//" as path. This function actually allows the same approach by not only looking at
# mountpounts for BTRFS file systems, but their contained subvolumes as well. By default, each and
# every subvolume simply gets a ".btrfs" directory to take snapshots and snapshots themself are of
# course excluded here.
#
# @stdin  BTRFS file systems of interest, one per line.
# @return All subvolumes, one per line.
#
btrfs_subvols_calc()
{
    local -a ret_val=()
    local -r array_txt="$(argsp_stdin_to_array)"
    eval "declare -a mps=${array_txt}"

    for mp in "${mps[@]}"
    do
        # The mountpoint itself obviously is a subvolume of interest as well already.
        ret_val+=(${mp})

        local subvols="$(btrfs subvolume list "${mp}" | awk '{print $9}')"

        # Subvolumes seem to have no parent UUID, while snapshots are "readonly" most likely. So
	# check for these attributes, which seems easier than to exclude all currently available
        # snapshots by their paths. That output doesn't include leading slashes, their common
	# directory might change its name etc.
        while IFS= read -r subvol
        do
            local abs_path="$(echo ${mp}/${subvol} | sed -r 's!^//!/!')"
            local show="$(btrfs subvolume show "${abs_path}")"
	    local sp='[[:space:]]+'
            local no_parent_uuid="$(echo "${show}" | grep --count -E "^${sp}Parent UUID:${sp}-$")"
            local is_read_only="$(  echo "${show}" | grep --count -E "^${sp}Flags:${sp}readonly$")"

            if [ "${no_parent_uuid}" = '1' ] && [ "${is_read_only}" = '0' ]
            then
                ret_val+=(${abs_path})
            fi
        done <<< "${subvols}"
    done

    declare -p ret_val | sed -e 's/^declare -a [^=]*=//'
}

getopt=$(getopt \
    --longoptions=debug,help,keep:,label: \
    --longoptions=dry-run,prefix:,quiet,verbose \
    --longoptions=syslog,writeable \
    --options=d,g,h,k:,l:,n,p:,q,v,w \
    -- "$@" ) \
    || exit 128

eval set -- "$getopt"

while [ $# -gt 0 ]
do
    case "$1" in
        (-d|--debug)
            debug=1
            quiet=''
            verbose=1
            shift 1
            ;;
        (-g|--syslog)
            use_syslog=1
            shift 1
            ;;
        (-h|--help)
            usage
            exit 0
            ;;
        (-k|--keep)
            if ! test $2 -gt 0 2>/dev/null; then
                log error "The $1 parameter must be a positive integer"
                exit 129
            fi
            keep=$2
            shift 2
            ;;
        (-l|--label)
            label="$2"
            shift 2
            ;;
        (-n|--dry-run)
            dry_run='echo'
            verbose=1
            log info "Doing a dry run. Not running these commands..."
            shift 1
            ;;
        (-p|--prefix)
            prefix="$2"
            while test "${prefix}" -gt 0
            do
                case $prefix in
                    ([![:alnum:]_.:\ -]*)
                        log error "The $1 parameter must be alphanumeric"
                        exit 130
                        ;;
                esac
                prefix="${prefix#?}"
            done
            prefix="$2"
            shift 2
            ;;
        (-q|--quiet)
            debug=''
            quiet=1
            verbose=''
            shift 1
            ;;
        (-v|--verbose)
            quiet=''
            verbose=1
            shift 1
            ;;
        (-w|--writeable)
            writeable=''
            shift 1
            ;;
        (--)
            shift 1
            break
            ;;
    esac
done

if [ $# -eq 0 ] ; then
    log error "The filesystem argument list is empty"
    exit 133
fi

# count the number of times '//' appears on the command line
slashies=0
for i in "$@"
do
    test "$i" = '//' && slashies=$(( $SLASHIES + 1 ))
done

if [ $# -gt 1 -a $slashies -gt 0 ] ; then
    log error "The // must be the only argument if it is given"
    exit 134
fi

snapname=${prefix}_${label}-$(date +%F-%H%M)
snapglob=".btrfs/${prefix}_${label}????????????????"

btrfs_list=$(grep btrfs /proc/mounts | awk '{print $2}' | btrfs_subvols_calc)
eval "declare -a btrfs_list=${btrfs_list}"

if [ "$1" = '//' ] ; then
    fs_list="${btrfs_list[@]}"
else
    fs_list="$@"
fi

log info "Doing snapshots of $fs_list"

for i in $fs_list
do
    printf "%s\n" "${btrfs_list[@]}" | grep -F -f - -q <(echo ${i})
    if [ $? -ne 0 ] ; then
        log err "It appears that '${i}' is not a BTRFS filesystem!"
        exit 135
    fi

    if [ ! -d "${i}/.btrfs" ] ; then
        ${dry_run} mkdir "${i}/.btrfs"
    fi

    # TODO Creating snapshots too frequently so that names overlap with an existing one, result in
    # some error message about read-only file system, not mentioning the actual snapshot itself at
    # all. Is bit difficult to understand when happening especially during tests, so might check if
    # the desired snapshot exists already.
    log notice $( ${dry_run} btrfs subvolume snapshot \
        ${writeable} "${i}" \
        "${i%/}/.btrfs/${snapname}" )
done

if [ ! -z "${keep}" ] ; then
    log info "Destroying all but the newest $keep snapshots"

    for i in $fs_list
    do
        snaps="$(btrfs subvolume list -g -o -s --sort=gen "${i}")"
	paths="$(echo "${snaps}" | sort -r -n -k 4 | awk '{print $NF}')"
	paths="$(echo "${paths}" | sed  -r 's!^[^/]+/.btrfs/!.btrfs/!')"

	while IFS= read j
        do
            if [ ! -z "${j#$snapglob}" ] ; then
                continue
            fi
            
	    keep=$(( $keep - 1 ))
            if [ $keep -lt 0 ] ; then
                log notice $( ${dry_run} btrfs subvolume \
                    delete -c ${i}/${j} )
            fi
	done <<< "${paths}"
    done
fi

# vim: set expandtab:ts=4:sw=4
